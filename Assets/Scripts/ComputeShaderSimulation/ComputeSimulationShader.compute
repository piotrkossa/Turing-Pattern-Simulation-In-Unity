// Equations: https://itp.uni-frankfurt.de/~gros/StudentProjects/Projects_2020/projekt_schulz_kaefer/

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Initialize
#pragma kernel AddSeed
#pragma kernel CSMain
#pragma kernel Draw

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// TO SET
Texture2D<float4> prevState;

float feedRate;
float killRate;

float diffusionU;
float diffusionV;

float deltaTime;

uint resolution;

bool stopOnWalls;

float2 lastDrawPosition;
float2 newDrawPosition;

uint seedSize;
//

void DrawSquare(uint2 p, uint diameter, uint2 id)
{
    if (id.x - p.x < diameter && id.y - p.y < diameter)
    {
        Result[id.xy] = float4(0.0, 1.0, 0.0, 1.0);
    }
}

[numthreads(8,8,1)]
void Initialize (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(1.0, 0.0, 0.0, 1.0); 
}


[numthreads(8,8,1)]
void Draw(uint3 id : SV_DispatchThreadID)
{
    float lineWidth = 3.0;

    float2 p  = id.xy;
    float2 a  = lastDrawPosition;
    float2 b  = newDrawPosition;

    float2 ab = b - a;
    float2 ap = p - a;

    float t = saturate(dot(ap, ab) / dot(ab, ab));
    float2 closest = a + ab * t;

    float dist = length(p - closest);

    if (dist < lineWidth)
    {
        Result[id.xy] = float4(0.0, 1.0, 0.0, 1.0);
    }
}


[numthreads(8,8,1)]
void AddSeed (uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(resolution/2, resolution/2);

    DrawSquare(center, seedSize, id.xy);
}


float4 GetNeighbour(int2 uv) {
    if (stopOnWalls) {
        uv.x = clamp(uv.x, 0, resolution);
        uv.y = clamp(uv.y, 0, resolution);
    }
    else {
        uv = (uv + resolution) % resolution;
    }
    return prevState[uv];
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float prevU = prevState[id.xy].x;
    float prevV = prevState[id.xy].y;

    float laplacianU = (
        GetNeighbour((int2)id.xy + int2(0, 1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(0, -1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(-1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(1, -1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, -1)) * 0.05 -
        prevU
    ).x;

    float laplacianV = (
        GetNeighbour((int2)id.xy + int2(0, 1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(0, -1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(-1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(1, -1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, -1)) * 0.05 -
        prevV
    ).y;

    float reaction = prevU * (prevV * prevV);

    float deltaU = (diffusionU * laplacianU) 
        - reaction 
        + (feedRate * (1.0 - prevU));

    float deltaV = (diffusionV * laplacianV) 
        + reaction 
        - ((killRate + feedRate) 
        * prevV);

    float newU = clamp(prevU + deltaU * deltaTime, 0.0, 1.0);
    float newV = clamp(prevV + deltaV * deltaTime, 0.0, 1.0);

    Result[id.xy] = float4(newU, newV, 0.0, 1.0);
}
