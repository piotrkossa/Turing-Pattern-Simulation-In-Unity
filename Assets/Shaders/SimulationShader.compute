// Equations: https://itp.uni-frankfurt.de/~gros/StudentProjects/Projects_2020/projekt_schulz_kaefer/

// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Initialize
#pragma kernel AddSeed
#pragma kernel CSMain
#pragma kernel Draw

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// TO SET
Texture2D<float4> prevState;

float feedRate;
float killRate;

float diffusionU;
float diffusionV;

float deltaTime;

uint resolution;

bool stopOnWalls;

uint pointToDrawX;
uint pointToDrawY;

//

[numthreads(8,8,1)]
void Initialize (uint3 id : SV_DispatchThreadID)
{
    Result[id.xy] = float4(1.0, 0.0, 0.0, 1.0); 
}

[numthreads(8,8,1)]
void Draw(uint3 id : SV_DispatchThreadID)
{
    if (id.x - pointToDrawX < 3 && id.y - pointToDrawY < 3)
    {
        Result[id.xy] = float4(0.0, 1.0, 0.0, 1.0);
    }
}

[numthreads(8,8,1)]
void AddSeed (uint3 id : SV_DispatchThreadID)
{
    uint2 center = uint2(resolution/2, resolution/2);
    uint seedSize = 10;
    if (id.x - center.x < seedSize && id.y - center.y < seedSize)
    {
        Result[id.xy] = float4(0.0, 1.0, 0.0, 1.0);
    }
}


float4 GetNeighbour(int2 uv) {
    if (stopOnWalls) {
        uv.x = clamp(uv.x, 0, resolution);
        uv.y = clamp(uv.y, 0, resolution);
    }
    else {
        uv = (uv + resolution) % resolution;
    }
    return prevState[uv];
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float prevU = prevState[id.xy].x;
    float prevV = prevState[id.xy].y;

    float laplacianU = (
        GetNeighbour((int2)id.xy + int2(0, 1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(0, -1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(-1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(1, -1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, -1)) * 0.05 -
        prevU
    ).x;

    float laplacianV = (
        GetNeighbour((int2)id.xy + int2(0, 1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(0, -1)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(-1, 0)) * 0.2 +
        GetNeighbour((int2)id.xy + int2(1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(1, -1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, 1)) * 0.05 +
        GetNeighbour((int2)id.xy + int2(-1, -1)) * 0.05 -
        prevV
    ).y;

    float reaction = prevU * (prevV * prevV);

    float deltaU = (diffusionU * laplacianU) 
        - reaction 
        + (feedRate * (1.0 - prevU));

    float deltaV = (diffusionV * laplacianV) 
        + reaction 
        - ((killRate + feedRate) 
        * prevV);

    float newU = clamp(prevU + deltaU * deltaTime, 0.0, 1.0);
    float newV = clamp(prevV + deltaV * deltaTime, 0.0, 1.0);

    newU = clamp(newU, 0.0, 1.0);
    newV = clamp(newV, 0.0, 1.0);

    Result[id.xy] = float4(newU, newV, 0.0, 1.0);
}
